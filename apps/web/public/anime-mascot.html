<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>High-Fidelity Cyberpunk Anime Character in Three.js</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
        }

        canvas {
            display: block;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #aaf;
            font-family: sans-serif;
            font-size: 14px;
            pointer-events: none;
            user-select: none;
        }
    </style>
</head>

<body>
    <div id="info">Orbit: Drag • Zoom: Scroll • Pan: Right-Drag</div>

    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.module.js';
        import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/controls/OrbitControls.js';
        import { EffectComposer } from 'https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/postprocessing/UnrealBloomPass.js';
        import { ShaderPass } from 'https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/postprocessing/ShaderPass.js';
        import { RGBShiftShader } from 'https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/shaders/RGBShiftShader.js';

        // Scene Setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x05000f);
        scene.fog = new THREE.FogExp2(0x0a001a, 0.001);

        // Camera
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 5000);
        camera.position.set(0, 1.65, 7.5);

        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true, logarithmicDepthBuffer: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio * 1.2);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.35;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // Post-Processing
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));

        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 2.1, 0.5, 0.65);
        composer.addPass(bloomPass);

        const rgbShift = new ShaderPass(RGBShiftShader);
        rgbShift.uniforms.amount.value = 0.0015;
        composer.addPass(rgbShift);

        // Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.08;
        controls.minDistance = 3;
        controls.maxDistance = 25;
        controls.maxPolarAngle = Math.PI / 1.8;

        // Global Lights
        const ambientLight = new THREE.AmbientLight(0x404080, 0.85);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.45);
        directionalLight.position.set(5, 10, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 500;
        scene.add(directionalLight);

        // Neon Point Lights for City Glow
        function addNeonLight(color, intensity, position) {
            const light = new THREE.PointLight(color, intensity, 60);
            light.position.copy(position);
            light.castShadow = true;
            light.shadow.bias = -0.005;
            scene.add(light);
            return light;
        }

        addNeonLight(0xff00bb, 7.5, new THREE.Vector3(12, 7, -15));
        addNeonLight(0x00ccff, 6.5, new THREE.Vector3(-14, 6, -10));
        addNeonLight(0xff9900, 5.5, new THREE.Vector3(8, 9, -25));
        addNeonLight(0x88ff00, 4.5, new THREE.Vector3(-8, 5, -20));

        // Character Group
        const character = new THREE.Group();
        character.position.y = -0.2; // Slight offset for composition
        scene.add(character);

        // ─── Face (More Detailed: Oval Shape with Extrusions for Chin/Cheeks) ───
        const faceGeometry = new THREE.SphereGeometry(0.95, 64, 64);
        const faceModifier = new THREE.BufferGeometry();
        const facePositions = faceGeometry.attributes.position.array.slice(); // Copy
        for (let i = 0; i < facePositions.length; i += 3) {
            if (facePositions[i + 1] < 0) facePositions[i + 1] *= 1.05; // Elongate chin
            if (Math.abs(facePositions[i]) > 0.4 && facePositions[i + 1] > 0.2) facePositions[i] *= 1.02; // Cheek puff
        }
        faceModifier.setAttribute('position', new THREE.BufferAttribute(new Float32Array(facePositions), 3));
        const faceMaterial = new THREE.MeshStandardMaterial({
            color: 0xfff2e5,
            roughness: 0.6,
            metalness: 0.03,
            emissive: 0x220044,
            emissiveIntensity: 0.1
        });
        const face = new THREE.Mesh(faceModifier, faceMaterial);
        face.position.y = 1.72;
        face.castShadow = true;
        face.receiveShadow = true;
        character.add(face);

        // ─── Eyes (Large, Glowing Purple with Highlights and Lashes Approximation) ───
        const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0xaa22ff });
        const eyeGlowMaterial = new THREE.MeshBasicMaterial({
            color: 0xdd55ff,
            transparent: true,
            opacity: 0.85,
            blending: THREE.AdditiveBlending
        });

        function createEye(xOffset) {
            const eyeGroup = new THREE.Group();
            eyeGroup.position.set(xOffset, 1.74, 0.88);

            // Iris
            const iris = new THREE.Mesh(new THREE.SphereGeometry(0.16, 32, 32), eyeMaterial);
            eyeGroup.add(iris);

            // Glow Halo
            const glow = new THREE.Mesh(new THREE.SphereGeometry(0.26, 24, 24), eyeGlowMaterial);
            eyeGroup.add(glow);

            // Highlight (small white dot)
            const highlight = new THREE.Mesh(
                new THREE.SphereGeometry(0.04, 16, 16),
                new THREE.MeshBasicMaterial({ color: 0xffffff })
            );
            highlight.position.set(0.05, 0.08, 0.12);
            eyeGroup.add(highlight);

            // Lashes (simple lines)
            for (let i = 0; i < 5; i++) {
                const lashCurve = new THREE.CatmullRomCurve3([
                    new THREE.Vector3(0, 0.18, 0.05),
                    new THREE.Vector3((i - 2) * 0.04, 0.22 + Math.random() * 0.02, 0.08)
                ]);
                const lashGeo = new THREE.TubeGeometry(lashCurve, 8, 0.005, 8, false);
                const lash = new THREE.Mesh(lashGeo, new THREE.MeshBasicMaterial({ color: 0x000000 }));
                eyeGroup.add(lash);
            }

            return eyeGroup;
        }

        character.add(createEye(-0.34));
        character.add(createEye(0.34));

        // ─── Mouth (Subtle Smirk) ───
        const mouthCurve = new THREE.CatmullRomCurve3([
            new THREE.Vector3(-0.18, 1.38, 0.85),
            new THREE.Vector3(0, 1.35, 0.88),
            new THREE.Vector3(0.22, 1.39, 0.85)
        ]);
        const mouthGeo = new THREE.TubeGeometry(mouthCurve, 32, 0.01, 8, false);
        const mouthMat = new THREE.MeshBasicMaterial({ color: 0xff5588 });
        const mouth = new THREE.Mesh(mouthGeo, mouthMat);
        character.add(mouth);

        // ─── Earrings (Dangling Loops) ───
        function createEarring(xOffset) {
            const earringGroup = new THREE.Group();
            earringGroup.position.set(xOffset, 1.45, 0.6);

            const ring1 = new THREE.Mesh(
                new THREE.TorusGeometry(0.08, 0.01, 8, 32),
                new THREE.MeshStandardMaterial({ color: 0xdddddd, metalness: 0.9, roughness: 0.1 })
            );
            ring1.rotation.x = Math.PI / 2;
            earringGroup.add(ring1);

            const ring2 = ring1.clone();
            ring2.position.y = -0.12;
            ring2.scale.set(0.7, 0.7, 0.7);
            earringGroup.add(ring2);

            return earringGroup;
        }

        character.add(createEarring(-0.5));
        character.add(createEarring(0.5));

        // ─── Hair (Advanced: Strands with Tubes + Particles for Volume) ───
        const hairStrandMaterial = new THREE.MeshStandardMaterial({
            color: 0xf0f0ff,
            roughness: 0.4,
            metalness: 0.05,
            emissive: 0x4400aa,
            emissiveIntensity: 0.15
        });

        function createHairStrand(start, control1, control2, end, thickness = 0.02) {
            const curve = new THREE.CubicBezierCurve3(start, control1, control2, end);
            const geo = new THREE.TubeGeometry(curve, 64, thickness, 8, false);
            return new THREE.Mesh(geo, hairStrandMaterial);
        }

        // Front Bangs
        character.add(createHairStrand(
            new THREE.Vector3(-0.4, 2.1, 0.4),
            new THREE.Vector3(-0.6, 1.9, 0.6),
            new THREE.Vector3(-0.5, 1.4, 0.8),
            new THREE.Vector3(-0.3, 1.2, 0.9),
            0.025
        ));
        character.add(createHairStrand(
            new THREE.Vector3(0.4, 2.1, 0.4),
            new THREE.Vector3(0.6, 1.9, 0.6),
            new THREE.Vector3(0.5, 1.4, 0.8),
            new THREE.Vector3(0.3, 1.2, 0.9),
            0.025
        ));
        // Side Locks
        for (let i = 0; i < 8; i++) {
            const offset = (i - 4) * 0.1;
            character.add(createHairStrand(
                new THREE.Vector3(offset, 2.0, 0.2),
                new THREE.Vector3(offset - 0.1, 1.6, 0.4),
                new THREE.Vector3(offset + 0.1, 1.2, 0.6),
                new THREE.Vector3(offset, 0.8, 0.7),
                0.018 + Math.random() * 0.01
            ));
        }
        // Back Hair
        for (let i = 0; i < 12; i++) {
            const offsetX = (Math.random() - 0.5) * 0.6;
            const offsetZ = -0.3 - Math.random() * 0.4;
            character.add(createHairStrand(
                new THREE.Vector3(offsetX, 1.9, offsetZ + 0.2),
                new THREE.Vector3(offsetX, 1.5, offsetZ),
                new THREE.Vector3(offsetX + (Math.random() - 0.5) * 0.2, 1.0, offsetZ - 0.1),
                new THREE.Vector3(offsetX, 0.6, offsetZ - 0.2),
                0.02
            ));
        }

        // Volumetric Particles for Hair Fill
        const hairParticleCount = 25000;
        const hairParticlePositions = new Float32Array(hairParticleCount * 3);
        for (let i = 0; i < hairParticleCount; i++) {
            const r = 1.0 + Math.random() * 0.8;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1) * 0.72;

            hairParticlePositions[i * 3] = r * Math.sin(phi) * Math.cos(theta) + (Math.random() - 0.5) * 0.2;
            hairParticlePositions[i * 3 + 1] = 1.72 + r * Math.cos(phi) * 1.4 - 0.95;
            hairParticlePositions[i * 3 + 2] = r * Math.sin(phi) * Math.sin(theta) - 0.4;

            if (Math.random() > 0.7) hairParticlePositions[i * 3 + 1] -= Math.random() * 1.2;
        }
        const hairParticleGeo = new THREE.BufferGeometry();
        hairParticleGeo.setAttribute('position', new THREE.BufferAttribute(hairParticlePositions, 3));
        const hairParticleMat = new THREE.PointsMaterial({
            color: 0xe8e8ff,
            size: 0.032,
            transparent: true,
            opacity: 0.88,
            blending: THREE.AdditiveBlending
        });
        const hairParticles = new THREE.Points(hairParticleGeo, hairParticleMat);
        character.add(hairParticles);

        // ─── Choker (Detailed: Leather with Metal Buckle and Ring) ───
        const chokerGeo = new THREE.TorusGeometry(1.0, 0.06, 12, 48);
        const chokerMat = new THREE.MeshStandardMaterial({ color: 0x0f0f0f, roughness: 0.5, metalness: 0.2 });
        const choker = new THREE.Mesh(chokerGeo, chokerMat);
        choker.position.set(0, 1.42, 0.1);
        choker.rotation.x = Math.PI / 2;
        character.add(choker);

        // Buckle
        const buckleGeo = new THREE.BoxGeometry(0.12, 0.08, 0.02);
        const buckleMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, metalness: 0.95, roughness: 0.15 });
        const buckle = new THREE.Mesh(buckleGeo, buckleMat);
        buckle.position.set(0, 1.42, 1.05);
        character.add(buckle);

        // Ring
        const ringGeo = new THREE.TorusGeometry(0.05, 0.015, 8, 32);
        const ring = new THREE.Mesh(ringGeo, buckleMat);
        ring.position.set(0, 1.42, 0.95);
        ring.rotation.y = Math.PI / 2;
        character.add(ring);

        // ─── Necklaces (Layered Chains with Pendant) ───
        const chainMaterial = new THREE.MeshStandardMaterial({ color: 0xbbbbbb, metalness: 0.92, roughness: 0.2 });

        const chain1Geo = new THREE.TorusGeometry(0.65, 0.015, 8, 48);
        const chain1 = new THREE.Mesh(chain1Geo, chainMaterial);
        chain1.position.set(0, 1.28, 0.42);
        chain1.rotation.x = Math.PI / 2;
        character.add(chain1);

        const chain2Geo = new THREE.TorusGeometry(0.72, 0.012, 8, 48);
        const chain2 = new THREE.Mesh(chain2Geo, chainMaterial);
        chain2.position.set(0, 1.20, 0.45);
        chain2.rotation.x = Math.PI / 2;
        character.add(chain2);

        // Pendant
        const pendantGeo = new THREE.SphereGeometry(0.08, 24, 24);
        const pendantMat = new THREE.MeshStandardMaterial({
            color: 0x88aaff,
            metalness: 0.9,
            roughness: 0.12,
            emissive: 0x2266bb,
            emissiveIntensity: 0.5
        });
        const pendant = new THREE.Mesh(pendantGeo, pendantMat);
        pendant.position.set(0, 1.05, 0.48);
        character.add(pendant);

        // ─── Jacket (Iridescent Holographic Material with Custom Shader, Multi-Part Geometry) ───
        // Custom Iridescent Shader
        const iridescentVertexShader = `
varying vec3 vNormal;
varying vec3 vViewPosition;
void main() {
  vNormal = normal;
  vViewPosition = - (modelViewMatrix * vec4(position, 1.0)).xyz;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`;

        const iridescentFragmentShader = `
varying vec3 vNormal;
varying vec3 vViewPosition;
uniform vec3 color;
uniform float time;
void main() {
  vec3 normal = normalize(vNormal);
  vec3 viewDir = normalize(vViewPosition);
  float fresnel = pow(1.0 - dot(normal, viewDir), 3.0);
  vec3 iridescent = 0.5 + 0.5 * sin(2.0 * 3.1416 * (fresnel + time * 0.1 + normal));
  gl_FragColor = vec4(color * iridescent + fresnel * vec3(0.2, 0.1, 0.3), 0.85);
}
`;

        const jacketMaterial = new THREE.ShaderMaterial({
            vertexShader: iridescentVertexShader,
            fragmentShader: iridescentFragmentShader,
            uniforms: {
                color: { value: new THREE.Color(0xffffff) },
                time: { value: 0 }
            },
            transparent: true,
            side: THREE.DoubleSide,
            blending: THREE.NormalBlending
        });

        // Jacket Body (Cylinder + Hood + Sleeves Approximation)
        const jacketBodyGeo = new THREE.CylinderGeometry(1.4, 1.0, 2.5, 48, 4, true);
        const jacketBody = new THREE.Mesh(jacketBodyGeo, jacketMaterial);
        jacketBody.position.y = 0.95;
        jacketBody.rotation.x = Math.PI;
        character.add(jacketBody);

        // Hood
        const hoodGeo = new THREE.SphereGeometry(1.1, 48, 48, 0, Math.PI * 2, 0, Math.PI / 2);
        const hood = new THREE.Mesh(hoodGeo, jacketMaterial);
        hood.position.set(0, 1.85, -0.2);
        hood.rotation.x = Math.PI / 2;
        character.add(hood);

        // Left Sleeve
        const leftSleeveGeo = new THREE.CylinderGeometry(0.35, 0.25, 1.8, 32);
        const leftSleeve = new THREE.Mesh(leftSleeveGeo, jacketMaterial);
        leftSleeve.position.set(-1.2, 0.8, 0);
        leftSleeve.rotation.z = Math.PI / 2 + 0.2;
        character.add(leftSleeve);

        // Right Sleeve (Partial, as per image)
        const rightSleeveGeo = new THREE.CylinderGeometry(0.35, 0.3, 1.2, 32);
        const rightSleeve = new THREE.Mesh(rightSleeveGeo, jacketMaterial);
        rightSleeve.position.set(1.1, 0.9, 0);
        rightSleeve.rotation.z = -Math.PI / 2 - 0.1;
        character.add(rightSleeve);

        // Straps / Buckles
        const strapMaterial = new THREE.MeshStandardMaterial({ color: 0x332211, roughness: 0.6, metalness: 0.3 });

        const leftStrapGeo = new THREE.BoxGeometry(0.1, 1.5, 0.05);
        const leftStrap = new THREE.Mesh(leftStrapGeo, strapMaterial);
        leftStrap.position.set(-0.8, 1.0, 0.5);
        leftStrap.rotation.y = 0.3;
        character.add(leftStrap);

        const rightStrapGeo = new THREE.BoxGeometry(0.1, 1.2, 0.05);
        const rightStrap = new THREE.Mesh(rightStrapGeo, strapMaterial);
        rightStrap.position.set(0.9, 1.1, 0.4);
        rightStrap.rotation.y = -0.2;
        character.add(rightStrap);

        // Metal Buttons
        const buttonMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.8, roughness: 0.2 });
        const button1 = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.02, 32), buttonMat);
        button1.position.set(-0.6, 1.2, 0.6);
        button1.rotation.x = Math.PI / 2;
        character.add(button1);

        const button2 = button1.clone();
        button2.position.set(0.7, 1.3, 0.55);
        character.add(button2);

        // ─── Black Inner Shirt ───
        const shirtGeo = new THREE.CylinderGeometry(1.0, 0.85, 1.2, 32);
        const shirtMat = new THREE.MeshStandardMaterial({ color: 0x080808, roughness: 0.75, metalness: 0 });
        const shirt = new THREE.Mesh(shirtGeo, shirtMat);
        shirt.position.y = 1.4;
        character.add(shirt);

        // ─── Cyberpunk City Background (Detailed Buildings, Signs, Crowd) ───
        // Buildings
        function createBuilding(width, height, depth, position, color) {
            const geo = new THREE.BoxGeometry(width, height, depth);
            const mat = new THREE.MeshStandardMaterial({ color, roughness: 0.8 });
            const building = new THREE.Mesh(geo, mat);
            building.position.copy(position);
            building.position.y = height / 2;
            building.receiveShadow = true;
            scene.add(building);
            return building;
        }

        createBuilding(10, 40, 8, new THREE.Vector3(20, 0, -40), 0x101020);
        createBuilding(12, 50, 10, new THREE.Vector3(-25, 0, -45), 0x151530);
        createBuilding(8, 35, 7, new THREE.Vector3(15, 0, -30), 0x202040);
        createBuilding(15, 60, 12, new THREE.Vector3(-18, 0, -55), 0x181838);

        // Neon Signs (Approximating Japanese Text with Colored Planes)
        function createNeonSign(color, sizeX, sizeY, position, rotationY = 0, textSimulation = false) {
            const mat = new THREE.MeshBasicMaterial({
                color,
                transparent: true,
                opacity: 0.95,
                side: THREE.DoubleSide
            });
            const sign = new THREE.Mesh(new THREE.PlaneGeometry(sizeX, sizeY), mat);
            sign.position.copy(position);
            sign.rotation.y = rotationY;
            scene.add(sign);

            const light = new THREE.PointLight(color, 8, 70);
            light.position.copy(position);
            light.position.y += 2;
            scene.add(light);

            if (textSimulation) {
                // Simulate text with small bars
                for (let j = 0; j < 5; j++) {
                    const bar = new THREE.Mesh(new THREE.BoxGeometry(0.2, Math.random() * 0.8 + 0.4, 0.1), new THREE.MeshBasicMaterial({ color: 0xffffff }));
                    bar.position.set(position.x + (Math.random() - 0.5) * sizeX * 0.8, position.y + (Math.random() - 0.5) * sizeY * 0.8, position.z + 0.1);
                    scene.add(bar);
                }
            }
        }

        createNeonSign(0xff0099, 6, 3.5, new THREE.Vector3(16, 8, -28), -0.35, true);
        createNeonSign(0x00ffcc, 5, 4, new THREE.Vector3(-20, 10, -35), 0.4, true);
        createNeonSign(0xffff00, 7, 3, new THREE.Vector3(10, 12, -45), -0.25, true);
        createNeonSign(0x8800ff, 4.5, 2.8, new THREE.Vector3(-12, 7, -25), 0.3, true);

        // Many Window Lights
        for (let i = 0; i < 300; i++) {
            const windowSize = Math.random() * 1.5 + 0.5;
            const window = new THREE.Mesh(
                new THREE.PlaneGeometry(windowSize, windowSize * 1.2),
                new THREE.MeshBasicMaterial({
                    color: [0x88ccff, 0xff88cc, 0xffff88, 0x88ff88][Math.floor(Math.random() * 4)],
                    side: THREE.DoubleSide
                })
            );
            window.position.set(
                (Math.random() - 0.5) * 150,
                Math.random() * 70 + 2,
                (Math.random() - 0.5) * 120 - 50
            );
            scene.add(window);
        }

        // Crowd Silhouettes (Simple Planes)
        for (let i = 0; i < 20; i++) {
            const person = new THREE.Mesh(
                new THREE.PlaneGeometry(0.8, 1.8),
                new THREE.MeshBasicMaterial({ color: 0x101010, transparent: true, opacity: 0.6 })
            );
            person.position.set(
                (Math.random() - 0.5) * 30,
                0.9,
                (Math.random() - 0.5) * 20 - 15
            );
            person.rotation.y = Math.random() * Math.PI * 2;
            scene.add(person);
        }

        // ─── Rain Effect (Dense, with Streaks and Splashes) ───
        const rainCount = 20000;
        const rainPositions = new Float32Array(rainCount * 3);
        const rainVelocities = new Float32Array(rainCount); // For varied speed
        for (let i = 0; i < rainCount; i++) {
            rainPositions[i * 3] = (Math.random() - 0.5) * 200;
            rainPositions[i * 3 + 1] = Math.random() * 100 + 20;
            rainPositions[i * 3 + 2] = (Math.random() - 0.5) * 150 - 60;
            rainVelocities[i] = 0.2 + Math.random() * 0.15;
        }

        const rainGeo = new THREE.BufferGeometry();
        rainGeo.setAttribute('position', new THREE.BufferAttribute(rainPositions, 3));

        const rainMat = new THREE.PointsMaterial({
            color: 0xbbddff,
            size: 0.12,
            transparent: true,
            opacity: 0.75,
            depthWrite: false
        });

        const rainSystem = new THREE.Points(rainGeo, rainMat);
        scene.add(rainSystem);

        // Ground for Rain Splashes (Reflective Plane)
        const groundGeo = new THREE.PlaneGeometry(300, 300);
        const groundMat = new THREE.MeshStandardMaterial({
            color: 0x0a0a1a,
            roughness: 0.1,
            metalness: 0.6
        });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // ─── Sparkles / Dust Particles ───
        const sparkleCount = 5000;
        const sparklePositions = new Float32Array(sparkleCount * 3);
        for (let i = 0; i < sparkleCount; i++) {
            sparklePositions[i * 3] = (Math.random() - 0.5) * 100;
            sparklePositions[i * 3 + 1] = Math.random() * 20 + 0.5;
            sparklePositions[i * 3 + 2] = (Math.random() - 0.5) * 80 - 30;
        }
        const sparkleGeo = new THREE.BufferGeometry();
        sparkleGeo.setAttribute('position', new THREE.BufferAttribute(sparklePositions, 3));
        const sparkleMat = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 0.05,
            transparent: true,
            opacity: 0.5,
            blending: THREE.AdditiveBlending
        });
        const sparkles = new THREE.Points(sparkleGeo, sparkleMat);
        scene.add(sparkles);

        // ─── Animation Loop ───
        let time = 0;
        function animate() {
            requestAnimationFrame(animate);
            time += 0.016; // Approx 60fps delta

            controls.update();

            // Character subtle animation
            character.position.y = Math.sin(time * 0.5) * 0.08 - 0.2;
            character.rotation.y = Math.sin(time * 0.3) * 0.02;

            // Hair sway
            hairParticles.rotation.y = Math.sin(time * 0.4) * 0.03;

            // Iridescent shader update
            jacketMaterial.uniforms.time.value = time;

            // Rain update
            const rainPosAttr = rainSystem.geometry.attributes.position;
            for (let i = 0; i < rainCount; i++) {
                rainPosAttr.array[i * 3 + 1] -= rainVelocities[i];
                if (rainPosAttr.array[i * 3 + 1] < 0) {
                    rainPosAttr.array[i * 3 + 1] = 100 + Math.random() * 20;
                }
            }
            rainPosAttr.needsUpdate = true;

            // Sparkles drift
            const sparklePosAttr = sparkles.geometry.attributes.position;
            for (let i = 0; i < sparkleCount; i++) {
                sparklePosAttr.array[i * 3 + 1] += Math.sin(time + i) * 0.001;
                sparklePosAttr.array[i * 3] += Math.cos(time + i * 0.5) * 0.0005;
            }
            sparklePosAttr.needsUpdate = true;

            composer.render();
        }

        animate();

        // Resize Handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>